
// Implementation of a dictionary using an AVL tree
// AVL Trees are balanced binary trees 

#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>

#include "avl-dictionary.h"

bool debug = false;

// Constructor
AVLDictionary::AVLDictionary()
{
	root = NULL;
	nElements = 0;
}

// Add a record to the dictionary. Returns false if key already exists
bool
AVLDictionary::addRecord( KeyType key, DataType record)
{
	if ( debug) {
		printf("------------------------------------\n");
		printf("addRecord(\"%s\",%d)\n",  key, record);
		printf("---------- Before -----------------\n");
		printNode("", root, 0);
	}
	
	//Find node to insert into 
	AVLNode *current = root;
	AVLNode *previous = NULL;

	while( current != NULL ) {
		previous = current;
		
		if( strcmp( current->key, key  )  == 0 ) {
			//Found existing node, substitute data
			current->data = record;
			return false;
		}
		else if( strcmp( current->key, key ) > 0 ) {
			//Key in node is larger than key to search,
			// take left child.
			current = current->left;
		}
		else{
			//Key in node is smaller than key to search,
			//take right child.
			current = current->right;
		}
	}//end of while

	//Node does not exist. Create it.
	AVLNode *n = new AVLNode( );
	assert( n != NULL );
	n->key = strdup(key);
	n->data = record;
	n->height = 1;
	n->left = NULL;
	n->right = NULL;
	n->parent = previous;
	nElements++;

	if( root == NULL ) {
		// First node in tree
		root = n;
		return true;
	}

	if( strcmp( previous->key, key ) > 0 ){
		//Insert as left child
		previous->left = n;
	}
	else{
		//Insert as right child
		previous->right = n;
	}
    

	//Height might not be valid anymore.
	//We need to restructure .

	if ( debug) {
		printf("---------- Before Restructure -----------------\n");
		printNode("", root, 0);
	}
	
	//Start at ' n' , up to the 'root' 
	restructure(n->parent);

	if (debug) {
		checkRecursive(root);
		
		printf("---------- After Restructure -----------------\n");
		printNode("", root, 0);
	}
		
	return true;
}

void
AVLDictionary::restructure(AVLNode * n) {
	//Balance the tree starting at n 
	//Go upwards until root is found
	AVLNode *z = n;
	while( z != NULL ){
		//Find parent of unbalanced tree
		int hLeft = 0;
		if( z->left != NULL ){
			hLeft = z->left->height;
		}

		int hRight = 0;

		if( z->right != NULL ){
			hRight = z->right->height; 
		}

		//Recompute height of z just in case it is wrong
		if( hLeft  > hRight ){
			z->height = hLeft + 1; 
		}
		else{
			z->height = hRight + 1;
		}

		//Verify if tree rooted by z is balanced
		int hdiff = hRight - hLeft;

		//Obtain the absolute value
		if( hdiff < 0 ){
			hdiff = -hdiff;
		}

		if( hdiff <= 1 ){
			//Tree rooted by z is balanced. Skip z.
			z = z->parent;
			continue;
		}

		//Identify y
		// y = Child of z with largest height
		AVLNode *y = NULL;
		int maxH = 0;
		if( z->left != NULL ){
			y = z->left;
			maxH = y->height;
		}

		if( z->right != NULL && maxH <= z->right->height ) {
			//Right child has largest height
			y = z->right;
		}

		assert( y != NULL );

		//Identify x
		// x = Child of y with largest height
		AVLNode *x = NULL;
		maxH = 0;
		if( y->left != NULL ){
			x = y->left;
			maxH = x->height;
		}

		if( y->right != NULL && maxH <= y->right->height ) {
			x = y->right;
		}

		assert( x != NULL );

		// Now rearrange x, y, z into a, b, c
		AVLNode *a, *b, *c, *t0, *t1, *t2, *t3;
		if( z->right == y ){
			//Case 1 or 2
			if( y ->right == x ){
				//Case 1
				a = z;
				b = y;
				c = x;
				t0 = a->left;
				t1 = b->left;
				t2 = c->left;
				t3 = c->right;
			}
			else{
				//Case 2
				a = z;
				b = x;
				c = y;
				t0 = a->left;
				t1 = b->left;
				t2 = b->right;
				t3 = c->right;
			}
		}
		else{
			//Case 3 or 4
			if( y ->left == x ){
				//Case 3
				a = x;
				b = y;
				c = z;
				t0 = a->left;
				t1 = a->right;
				t2 = b->right;
				t3 = c->right;
			}
			
			else{
				//Case 4
				a = y;
				b = x;
				c = z;
				t0 = a->left;
				t1 = b->left;
				t2 = b->right;
				t3 = c->right;
			}
		}
		
		//Connect to parent of z
		AVLNode *p = z->parent;
		if( p == NULL ){
			// z is root, make root parent to b
			root = b; 
		}    
		else {
			// Connect b to the parent of z
			if( p->left == z ){
				// Connect to the left
				p->left = b;
			}
			else{
				//Connect to the right
				p->right = b;
			}
		}
        

		//update b
		b->parent = p;
		b->left = a;
		b->right = c;
		
		//update a
		a->parent = b;
		a->left = t0;
		a->right = t1;
		
		//update c
		c->parent = b;
		c->left = t2;
		c->right = t3;
		
		if( t0 != NULL ){
			t0->parent = a;
		}
		
		if( t1 != NULL ){
			t1->parent = a;
		}
		
		if( t2 != NULL ){
			t2->parent = c;
		}
		
		if( t3 != NULL ){
			t3->parent = c;
		}
		
		
		//We need to update the heights of a,b,c
		int maxheight = 0;
		if( a->left != NULL ){
			maxheight = a->left->height;
		}
		
		if( a->right != NULL && a->right->height > maxheight ){
			maxheight = a->right->height;
		}
		
		a->height = maxheight + 1;
		maxheight = 0;
		
		if( c->left != NULL ){
			maxheight = c->left->height;
		}
		
		if( c->right != NULL &&
		    c->right->height > maxheight ){
			maxheight = c->right->height;
		}
		
		c->height = maxheight + 1;
		
		maxheight = 0;
		
		if( b->left != NULL ){
			maxheight = b->left->height;
		}
		
		if( b->right != NULL &&
		    b->right->height > maxheight ){
			maxheight = b->right->height;
		}
		
		b->height = maxheight + 1;

		//Go one node above
		z = p;
	}// end of while
}

// Find a key in the dictionary and return corresponding record or NULL
DataType
AVLDictionary::findRecord( KeyType key)
{
	//Find node to insert into 
	AVLNode *current = root;

	while( current != NULL ) {
		if( strcmp( current->key, key  )  == 0 ) {
			//Found existing node, substitute data
			return current->data;
		}
		else if( strcmp( current->key, key ) > 0 ) {
			//Key in node is larger than key to search,
			// take left child.
			current = current->left;
		}
		else{
			//Key in node is smaller than key to search,
			//take right child.
			current = current->right;
		}
	}//end of while
	
	return NULL;
}

// Removes one element from the dictionary
bool
AVLDictionary::removeElement(KeyType key)
{
	if (debug) {
		printf("------------------------------------\n");
		printf("removeElement(\"%s\")\n",  key);
		printf("---------- Before -----------------\n");
		printNode("", root, 0);
	}

	// Find element to remove

	//Find node to remove
	AVLNode *current = root;

	while( current != NULL ) {
		if( strcmp( current->key, key  )  == 0 ) {
			//Found existing node.
			break;
		}
		else if( strcmp( current->key, key ) > 0 ) {
			//Key in node is larger than key to search,
			// take left child.
			current = current->left;
		}
		else{
			//Key in node is smaller than key to search,
			//take right child.
			current = current->right;
		}
	}//end of while

	if ( current == NULL) {
		// Key not found
		if (debug) {
			printf("Key not found\n");
		}
		return false;
	}

	// Check if this is not an external node
	if (current->left != NULL and current->right!=NULL) {
		// Removing internal node. Find predecessor
		AVLNode * pred = current->left;
		while ( pred->right!= NULL) {
			pred = pred->right;
		}

		// Now put key of predecessor in internal node
		current->key = pred->key;
		current->data = pred->data;
		
		// Now set the current to be the predecessor.
		current = pred;
	}

	// Find a child of current that is not NULL if any
	AVLNode * child = NULL;
	if (current->left != NULL) {
		child = current->left;
	}
	else {
		child = current->right;
	}

	if (current->parent->right == current) {
		// Attach in right side.
		current->parent->right = child;
	}
	else {
		// Attach in left side
		current->parent->left = child;
	}

	if (child!=NULL) {
		child->parent = current->parent;
	}

	// Now fix tree starting at child->parent
	restructure(current->parent);

	// Now recycle current
	delete current;

	nElements++;

	if (debug) {
		printf("---------- After -----------------\n");
		printNode("", root, 0);

		checkRecursive(root);
	}
	
	return true;
}

// Returns all the elements in the table as an array of strings.
// *n is the size of the table and it is returned by reference
KeyType *
AVLDictionary::keys(int * n)
{
	KeyType * a = (KeyType *) malloc(nElements * sizeof(KeyType));
	*n = 0;
	addKeysRecursive(root, a, n);

	return a;
}

// Add keys recursively
void
AVLDictionary::addKeysRecursive(AVLNode * node, KeyType * a, int * n) {
	if (node==NULL) {
		return;
	}
	
	a[*n] = node->key;
	(*n)++;
	addKeysRecursive(node->left, a, n);
	addKeysRecursive(node->right, a, n);
}

